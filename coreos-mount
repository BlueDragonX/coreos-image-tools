#!/bin/bash
# Mount/Unmount a CoreOS image.

TOOLS="$(cd "$(dirname "$0")"; pwd)"

err() {
	echo "$@" >&2
}

die() {
	err "error:" "$@"
	exit 1
}

usage() {
	test -n "$1" && err "error:" "$@"
	err "usage: $0 IMAGE ACTION [OPTIONS]"
	err "Mount/Unmount CoreOS partitions."
	err ""
	err "Valid Commands:"
	err "    mount [LABEL] [MNT]     Mount the image partition LABEL at MNT."
	err "    umount [MNT]            Unmount the image mounted at MNT."
	exit 1
}

abspath() {
	# usage: abspath PATH
	# Print the absolute path to PATH.
	cd "$(dirname "$1")"
	echo "$(pwd)/$(basename "$1")"
}

lo_find() {
	# usage: lo_find IMAGE
	# Print the loop device the image is attached to.
	losetup -l | egrep " $(abspath "$1")$" | sed -e 's/ .*//g'
}

lo_available() {
	# usage: lo_available
	# Print the first available loop device.
	local n=0
	while losetup -l | egrep -q "^/dev/loop$n "; do
		n=$((n + 1))
	done
	local loop="/dev/loop$n"
	test -b "$loop" && echo "$loop" || return 1
}

lo_part_prefix() {
	# usage: lo_part_prefix DEVICE
	# Print the aPrtition prefix for the loop device.
	echo "$1" | sed -r -e 's|^/dev/loop([0-9]+)|/dev/mapper/loop\1p|'
}

blk_find_label() {
	# usage: blk_find_label DEVICE LABEL
	# Find a partition by its label.
	blkid | egrep "^$(lo_part_prefix "$1")[0-9]+:.* LABEL=\"${2}\"" | \
		sed 's/:.*//g'
}

is_root() {
	# usage: is_root LABEL
	# Check if a partition is root.
	echo "$1" | egrep -q '^ROOT-[AB]$'
}

image_mount() {
	# usage: mount IMAGE LABEL MNT
	# Mount a CoreOS image.
	local image="$1"
	local label="$2"
	local mnt="$3"

	# prepare mnt directory
	mkdir -p "$mnt" || die "failed to create mount point"

	# attach loop device
	local lo="$(lo_find "$image")"
	if [ -z "$lo" ]; then
		lo="$(lo_available)"
		test -n "$lo" || die "no loop devices available"
		losetup "$lo" "$image" || die "failed to attach '$lo' to '$image'"
	fi

	# add loop partitions
	if ! kpartx -a "$lo"; then
		losetup -d "$lo"
		die "failed to create loop partitions"
	fi

	# find labeled partition
	local part="$(blk_find_label "$lo" "$label")"
	if [ -z "$part" ]; then
		kpartx -d "$lo"
		losetup -d "$lo"
		die "could not find partition '$label'"
	fi

	# make root writable
	if is_root "$label"; then
		if ! "$TOOLS/coreos-rw" enable "$part"; then
			kpartx -d "$lo"
			losetup -d "$lo"
			die "failed to make '$part' writable"
		fi
	fi

	# mount partition
	if ! mount "$part" "$mnt"; then
		kpartx -d "$lo"
		losetup -d "$lo"
		die "failed to mount '$part' at '$mnt'"
	fi
}

image_umount() {
	# usage: umount IMAGE LABEL
	# Unmount a CoreOS image.
	local image="$1"
	local label="$2"

	# find loop device image is attached to
	local lo="$(lo_find "$image")"
	test -n "$lo" || die "image not attached to a loop device"

	# find partition by label
	local part="$(blk_find_label "$lo" "$label")"

	# unmount partition
	if [ -n "$part" ]; then
		if mount | egrep -q "^${part} "; then
			umount "$part" || die "failed to unmount '$part'"
		else
			err "partition not mounted"
		fi
	else
		test -n "$part" || err "could not find partition '$label'"
	fi

	# make root partition read-only
	if is_root "$label"; then
		"$TOOLS/coreos-rw" disable "$part" || \
			die "failed to make '$part' writable"
	fi

	# if no other partitions on image mounted:
	#   remove loop partition devices
	#   detach loop device
	local prefix="$(lo_part_prefix "$lo")"
	if ! mount | egrep -q "^${prefix}[0-9]+ "; then
		kpartx -d "$lo"
		losetup -d "$lo"
	fi
}


which blkid &> /dev/null || die "blkid not found in PATH"
which kpartx &> /dev/null || die "kpartx not found in PATH"
which losetup &> /dev/null || die "losetup not found in PATH"

image_umount "$@"
exit


gpt_print() {
	# usage: gpt_print DEVICE
	# Print the GPT partition table. Columns are:
	#   Number, Start Sector, End Sector, Size, Code, Label
	echo -ne 'p\nq\n' | gdisk "$1" | egrep '^[ ]+[0-9]'
}

gpt_find_label() {
	# usage: gpt_find_label DEVICE LABEL
	# Find a GPT partition by its label.
	local n=$(gpt_print "$1" | egrep " ${2}$" | awk '{print $1}')
	test -n "$n" || return 1
}

is_dir_empty() {
	# usage: is_dir_empty DIR
	# Check if a directory is empty.
	test $(find "$1" -maxdepth 0 -empty | wc -l) -eq 0
}


